<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ELK: 使用 Docker 搭建 ELK 环境]]></title>
    <url>%2F2018%2F07%2F20%2FELK-%E4%BD%BF%E7%94%A8-Docker-%E6%90%AD%E5%BB%BA-ELK-%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[​ 这里使用 Docker 直接搭建 ELK 环境, 因为 Docker 有第三方提供了 elk 的包, 减少了配置量.当然也可以用 ELK提供的官方 Docker 包或者直接安装, 但是因为工作需要就那么折腾了. Docker 安装 Docker 官方安装教程 https://docs.docker.com/v17.09/engine/installation/linux/docker-ce/centos/#prerequisites 123456789101112131415161718192021# 更新yum update# 删除旧版本避免冲突sudo yum remove docker \ docker-common \ docker-selinux \ docker-engine# 安装依赖sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2# 安装 Docker 的 yum 源sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo# 安装 Dockersudo yum install docker-ce# 开启 Dockersudo systemctl start docker# 开启 Dockerdocker info 这样 Docker 就安装好了, 一般不会遇到什么问题.需要注意的是这是 CentOS 的安装顺序, 其他系统参考官方教程. ELK 安装 ELK Docker 文档 http://elk-docker.readthedocs.io/ 安装 ELK Docker 镜像 12345678docker pull sebp/elkdocker run -p 5001:5601 -p 9200:9200 -p 5044:5044 -p 9300:9300 \ -v /data/elk/conf.d:/etc/logstash/conf.d -it --name elk sebp/elk# 这个包直接 run 就好了, 需要注意的是端口要映射出来, 如果需要修改配置就要映射配置文件.# 配置文件文件夹在文档中能找到, 相关配置也在里面.# 5601 -&gt; Kibana# 5044 -&gt; Logstash# 9200, 9300 -&gt; Elasticsearch 在文档里面提到一个先决条件, 就是 max_map_count 要大于 262144. Linux 设置 max_map_count 1234# 查看设置的 max_map_count 是多少sysctl vm.max_map_count# 设置 max_map_count 大于300000sysctl -w vm.max_map_count=300000 注意, 必须在主机上更改限制; 不能在容器内更改. Docker for Mac 设置 max_map_count在启动容器时设置环境变量 -e MAX_MAP_COUNT=300000如果没有问题就已经装好了, 可以通过 Kibana 和 Elasticsearch:9200 连接查看是否安装完成.]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>Elasticsearch</tag>
        <tag>Logstash</tag>
        <tag>Kibana</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流畅的Python]]></title>
    <url>%2F2018%2F05%2F05%2F%E6%B5%81%E7%95%85%E7%9A%84python%2F</url>
    <content type="text"><![CDATA[流畅的python阅读笔记，流畅的python主要是讲了python的进阶特性。 第一章 Python数据模型 在 Python 中使用双下划线开头，双下划线结尾的方法就是 Python 的特殊方法。Python 会在碰到特殊句法的时候，会使用特殊方法去执行一些对象操作。这些特殊方法能让对象支持这些操作： 迭代， 集合类， 属性访问， 运算符重载， 函数和方法的调用， 对象的创建和销毁， 字符串表示形式和格式化， 管理上下文。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Web开发测试驱动方法 笔记]]></title>
    <url>%2F2018%2F02%2F26%2FPython-Web%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Python Web开发测试驱动方法的笔记django version: 1.11.7Python version: 3.6.2 第一部分 (第 1~6章 ): 基础知识第 1 章 功能测试协助安装Django测试山羊: “先测试,先测试,先测试”(重要的事说三遍)测试山羊: “没有测试什么也别做”这一章主要讲的是编写一个简单的测试查看Django是否安装正确,没有什么问题. 第 2 章 使用unittest模块扩展功能测试注释书中有一部分说到了注释.注释是有用的, 可以添加上下文,说明代码的目的,但是简单而重复的注释是毫无意义的.而且有一定风险,如果更新了代码后没有修改注释,会误导别人.例如:12# 把wibble的值增加 1wibble += 1 unittest模块 以test_开头的方法都是测试方法 测试方法的名称应该有意义 setUp和tearDown在该测试类的各个测试方法运行前和运行后执行 预期失败,应该预期测试方法的失败和失败方式 12345678910111213141516class XXTest(unittest.TestCase): def setUp(self): &apos;&apos;&apos;测试开始前执行&apos;&apos;&apos; self.browser = webdriver.Chrome() # 设置浏览器驱动 self.browser.implicitly_wait(3) # 隐式等待,在页面加载的时候让Selenium先等待 def tearDown(self): &apos;&apos;&apos;测试结束后执行&apos;&apos;&apos; self.browser.quit() # 设置退出浏览器 def testxxx(self): self.asserIn(&apos;XX&apos;, self.browser.title) # 测试浏览器标题是不是包含XXif __name__ == &apos;main&apos;: # 启动unittest测试程序,禁止抛出ResourceWarning异常 unittest.main(warnings=&apos;ignore&apos;) 第 3 章 使用单元测试测试简单的首页单元测试和功能测试的区别单元测试: 站在程序员的角度从内部测试应用功能测试: 站在用户的角度从外部测试应用 单元测试和功能测试的工作流程 先写功能测试, 从用户的角度描述应用的新功能 功能测试失败后,想办法编写代码让它通过(至少通过当前失败).使用一个或多个单元测试定义希望代码实现的效果,尽量覆盖每一行代码(至少一个) 单元测试失败后,写最少的应用代码让单元测试通过.直到功能测试有进展. 再次运行功能测试,然后根据新的测试结果编写新的单元测试和代码. 单元测试代码123456789101112131415161718192021222324# tests.pyclass HomePageTest(TestCase): def test_root_page_resolve(self): &quot;&quot;&quot;路径解析测试&quot;&quot;&quot; found = resolve(&apos;/&apos;) self.assertEqual(found.func, home_page) def test_home_page_returns_html(self): &quot;&quot;&quot;页面HTML解析&quot;&quot;&quot; request = HttpRequest() response = home_page(request) self.assertTrue(response.content.startswith(b&apos;&lt;html&gt;&apos;)) self.assertIn(b&apos;&lt;title&gt;To-Do lists&lt;/title&gt;&apos;, response.content) self.assertTrue(response.content.endswith(b&apos;&lt;/html&gt;&apos;))# lists/views.pydef home_page(request): return HttpResponse(&apos;&lt;html&gt;&lt;title&gt;To-Do lists&lt;/title&gt;&lt;/html&gt;)# superlists/urls.pyurlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^$&apos;, view=views.home_page, name=&apos;home_page&apos;),] 单元测试时的问题在django 1.11.7中resolve的导入是1from django.urls import resolve resolve()中的path路径是在urls的路径加根目录1234found = resolve(&apos;/lists/&apos;)urls:url(r&apos;^lists/&apos;, view=views.home_page, name=&apos;home_page&apos;), 第 4 章 编写这些测试有什么用 测试有点多了?是不是太琐细了?我们并不是大神,也不是大牛,我们没办法避免错误,哪怕是大神可能也会出现简单的错误.TDD可以记录我们编码的进程,让我们不会反复的犯同一个错误.测试可能会很简单,但是有占位作用,当函数变复杂后就可能没那么容易测试了.在学习新框架的时候TDD也能帮助学习,排除错误. 123456def test_home_page_returns_html(self): &quot;&quot;&quot;页面HTML解析&quot;&quot;&quot; request = HttpRequest() response = home_page(request) expected_html = render_to_string(&apos;home.html&apos;) self.assertEqual(response.content.decode(), expected_html) 第 5 章 保存用户输入单元测试规则 不测试常量 assert语句123assertIn(xx, yy) yy中有没有xxassertEqual(xx,yy) xx和yy是不是一样assertTrue(xx) xx结果是不是True find_element_by 语句1234find_element_by_id(xx)find_element_by_tag_name(xx)find_elements_by_tag_name(xx)]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
        <tag>TDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在aws 创建git 仓库]]></title>
    <url>%2F2018%2F02%2F16%2F%E5%9C%A8aws-%E5%88%9B%E5%BB%BAgit-%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[在aws上创建git仓库 在本地创建ssh公钥和私钥1ssh-keygen -t rsa -C &quot;xxx&quot; 在aws创建authortized_keys文件存放刚才生成的公钥。1234cd ~mkdir .ssh &amp;&amp; cd .sshtouch authorized_keysvi authorized_keys 创建git仓库12mkdir 仓库名称 &amp;&amp; cd 仓库名称git init --bare]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>aws</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 存储过程实例]]></title>
    <url>%2F2018%2F02%2F16%2FMySQL-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[MySQL 存储过程的一些例子,添加了一些注释 1. 存储过程存储过程11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374CREATE PROCEDURE `SP_eco_stat`(IN report_type VARCHAR(100), IN start_datetime DATETIME, IN end_datetime DATETIME) # 存储过程名称（传入参数） COMMENT &apos;计算经济系统数据&apos; # 备注信息BEGIN # 存储过程开始 DECLARE `from` VARCHAR(100); #变量声明，要在前面 DECLARE `detail` VARCHAR(100); DECLARE `country` VARCHAR(100); DECLARE `change` VARCHAR(100); DECLARE `count` VARCHAR(100); DECLARE `user` VARCHAR(100); DECLARE `stop_flag` INT DEFAULT 0; # DEFAULT设置默认值，没有则为null DECLARE `date` DATE; DECLARE _Cursor CURSOR FOR SELECT # 声明光标 XX 光标名 XX a.`from` AS `from`, a.detail AS `detail`, a.country AS `country`, SUM(a.`change`) AS `change`, SUM(1) AS `count`, count(DISTINCT (a.uid)) AS `user` FROM credits a WHERE a.`time` BETWEEN start_datetime AND end_datetime AND a.`change` &gt; 0 GROUP BY a.`from`, a.`change`, a.country; DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;02000&apos; SET stop_flag = 1; # 声明停止时stop_flag=1 SET `date` = CURDATE() + INTERVAL -(1) DAY; # 变量赋值 # 调试开关 SET @__logCallDebug = 1; CALL SP_LogCall(&apos;SP_eco_stat&apos;, # 调用存储过程 CONCAT_WS(&apos;,&apos;, QUOTE(report_type), QUOTE(start_datetime), QUOTE(end_datetime)), &apos;begin...&apos;); OPEN _Cursor; #打开光标 FETCH _Cursor INTO `from`, `detail`, `country`, `change`, `count`, `user`; # 调用光标并赋值 WHILE `stop_flag`&lt;&gt;1 DO # while循环 IF `country` IS NULL # if 判断 THEN SET `country` = &apos;&apos;; END IF; IF `change` IS NULL THEN SET `change` = &apos;&apos;; END IF; IF `detail` IS NULL THEN SET `detail` = &apos;&apos;; END IF; IF `from` IS NULL THEN SET `from` = &apos;&apos;; END IF; IF `count` IS NULL THEN SET `count` = &apos;&apos;; END IF; REPLACE INTO day_amounts(type1, type2, type3, type4, type5, DATE, amount) VALUES (report_type, `from`, `detail`, `country`, &apos;change&apos;, `date`, `change`), (report_type, `from`, `detail`, `country`, &apos;count&apos;, `date`, `count`), (report_type, `from`, `detail`, `country`, &apos;user&apos;, `date`, `user`); # INSERT INTO的强化版，如果有存在相同的主键时对该行进行更新 FETCH _Cursor INTO `from`, `detail`, `country`, `change`, `count`, `user`; END WHILE;CLOSE _Cursor; # 关闭光标CALL SP_LogCallDebug(&apos;end.&apos;);END # 存储过程结束 存储过程21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192CREATE PROCEDURE SP_day_n_retention(IN calcdate_offset INT) COMMENT &apos;日留存计算&apos; BEGIN DECLARE yesterday DATE; # 调试开关 SET @__logCallDebug = 1; CALL SP_LogCall(&apos;SP_day_n_retention&apos;, CONCAT_WS(&apos;,&apos;, calcdate_offset), &apos;begin...&apos;); # day0安装 CALL SP_LogCallDebug(&apos;day0...&apos;); SET yesterday = adddate(date(NOW()), INTERVAL calcdate_offset DAY); # 获取当前【输入数字】天前的时间 date(NOW()) 现在时间 adddate 【DATE_ADD()的同义词】 获取【输入数字】天前的时间 # 安装量(去重) SET @_install_user_count = ( SELECT amount FROM day_amounts WHERE type1 = &apos;user&apos; AND type3 = &apos;new&apos; AND date BETWEEN CONCAT(yesterday, &apos; 00:00:00&apos;) AND CONCAT(yesterday, &apos; 23:59:59&apos;) # BETWEEN 多少和多少之间 CONCAT 连接字符串 ); # 插入或者更新day0 REPLACE INTO day_amounts ( type1, type2, type3, type4, type5, date, amount ) VALUES ( &apos;user&apos;, &apos; &apos;, &apos;retention&apos;, &apos; &apos;, &apos;day0&apos;, yesterday, @_install_user_count ); IF calcdate_offset &lt; 0 # 判断【输入数字】是否小于0 THEN BEGIN # exec执行错误 DECLARE errStr VARCHAR(10240); DROP TABLE IF EXISTS tmp_uuid; # 如果临时表存在则删除 CREATE TEMPORARY TABLE tmp_uuid ( # 创建临时表，只在当前连接有效 uuid VARCHAR(64) NOT NULL, PRIMARY KEY (uuid) ) ENGINE = MYISAM # 数据库存储引擎 和InnoDB相比更注重性能但功能也较少 CHARACTER SET latin1 COLLATE latin1_general_ci; INSERT tmp_uuid SELECT a.uid FROM users_active a WHERE a.act_time BETWEEN CONCAT(yesterday, &apos; 00:00:00&apos;) AND CONCAT(yesterday, &apos; 23:59:59&apos;); SET @days = &apos;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,35,42,49,56,60,63,70,77,84,90&apos;; WHILE CHAR_LENGTH(@days) &gt; 0 DO # while 循环 SET @dayN = SUBSTRING_INDEX(@days, &apos;,&apos;, 1); # 截取在第一个【,】之前的字符 CALL SP_LogCallDebug(concat(&apos;day&apos;, @dayN, &apos;...&apos;)); # 日期偏移(例如: day1 = 1, day2 = 2, ...) SET @_dayOffset = (SELECT -CAST(@dayN AS SIGNED)); # CAST 获取一个类型的值并产生另一个类型的值 还有CONVERT(value, type) # 在用户表和日志表里找N天前安装的用户的留存量 DROP TEMPORARY TABLE IF EXISTS day_n_retention; SET @_execStr = CONCAT( &apos;REPLACE INTO day_amounts(type1,type2,type3,type4,type5,date,amount) &apos;, &apos;SELECT &quot;user&quot;, &quot;day&quot;, &quot;retention&quot;, &quot; &quot;, &quot;day&apos;, @dayN, &apos;&quot;, &quot;&apos;, adddate(yesterday, @`_dayOffset`), &apos;&quot;, count(DISTINCT(u.uid))&apos;, &apos;FROM users u, tmp_uuid a &apos;, &apos;WHERE u.uid = a.uuid AND &apos;, &apos;u.reg_time BETWEEN &quot;&apos;, adddate(yesterday, @`_dayOffset`), &apos; 00:00:00&quot; AND &quot;&apos;, adddate(yesterday, @`_dayOffset`), &apos; 23:59:59&quot;&apos; ); CALL SP_LogCallDebug(@_execStr); CALL SP_Exec(@_execStr, errStr); SET @days = RIGHT(@days, LENGTH(@days) - LENGTH(@dayN) - 1); END WHILE; END; END IF ; CALL SP_LogCallDebug(&apos;end.&apos;); END;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>存储过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSL证书生成命令]]></title>
    <url>%2F2018%2F02%2F16%2FSSL%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[SSL证书的生成 1234567891011# 生成一个RSA密钥$ openssl genrsa -des3 -out 33iq.key 1024# 拷贝一个不需要输入密码的密钥文件$ openssl rsa -in 33iq.key -out 33iq_nopass.key# 生成一个证书请求$ openssl req -new -key 33iq.key -out 33iq.csr# 自己签发证书$ openssl x509 -req -days 365 -in 33iq.csr -signkey 33iq.key -out 33iq.crt]]></content>
      <categories>
        <category>commond</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>commond</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django HTTPS配置]]></title>
    <url>%2F2018%2F02%2F16%2FDjango-HTTPS%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Django启动HTTPS服务的配置 在settings.py 中 添加以下配置1234SECURE_PROXY_SSL_HEADER = (&apos;HTTP_X_FORWARDED_PROTO&apos;, &apos;https&apos;)SECURE_SSL_REDIRECT = TrueSESSION_COOKIE_SECURE = TrueCSRF_COOKIE_SECURE = True - Django Django启动HTTPS服务的配置 在settings.py 中 添加以下配置1234SECURE_PROXY_SSL_HEADER = (&apos;HTTP_X_FORWARDED_PROTO&apos;, &apos;https&apos;)SECURE_SSL_REDIRECT = TrueSESSION_COOKIE_SECURE = TrueCSRF_COOKIE_SECURE = True]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx-HTTP-配置]]></title>
    <url>%2F2018%2F02%2F16%2FNginx-HTTP-%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[HTTP Nginx配置的记录,和一些解析注释 1234567891011121314151617181920212223user LuGH LuGH; # 指定nginx worker进程运行用户以及用户组worker_processes 2; # 指定了nginx要开启的进程数error_log /home/LuGH/logs/nginx_log/error.log crit; # 用来定义全局错误日志文件pid /usr/local/nginx/logs/nginx.pid; # 用来指定进程id的存储文件位置events &#123; # 用来指定nginx的工作模式及连接数上限 worker_connections 1024; # 定义nginx每个进程的最大连接数&#125;http &#123; include mime.types; # 对配置文件所包含的文件设定 default_type application/octet-stream; # 为标准MIME映射未指定任何内容的文件指定默认的mime类型 sendfile on; # 用于开启高效文件传输模式 keepalive_timeout 65; # 指定了客户端与服务器长连接的超时时间 server &#123; listen 80; # 监听端口 server_name localhost; # 服务器名称 location / &#123; proxy_pass http://localhost:9000; # 忽略代理 proxy_redirect default; # 默认重定向 &#125; &#125;&#125;]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx HTTPS 的简单配置]]></title>
    <url>%2F2018%2F02%2F16%2FNginx-HTTPS-%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Nginx 配置的记录，和一些解析注释。 12345678910111213141516171819202122232425262728293031323334353637user LuGH LuGH; # 主模块指令，指定nginx worker进程运行用户以及用户组worker_processes 2; # 指定了nginx要开启的进程数error_log /home/LuGH/logs/nginx_log/error.log crit; # 用来定义全局错误日志文件pid /usr/local/nginx/logs/nginx.pid; # 用来指定进程id的存储文件位置events &#123; # 用来指定nginx的工作模式及连接数上限 worker_connections 1024; # 定义nginx每个进程的最大连接数&#125;http &#123; include mime.types; # 对配置文件所包含的文件设定 default_type application/octet-stream; # 为标准MIME映射未指定任何内容的文件指定默认的MIME类型。 sendfile on; # 用于开启高效文件传输模式 keepalive_timeout 65; # 指定了客户端与服务器长连接的超时时间 upstream sserver &#123; # 提供一个简单方法来实现在轮询和客户端IP之间的后端服务器负荷平衡 server 127.0.0.1:9000; # 后端服务器ip &#125; server &#123; listen 443; # 监听端口 server_name local.com; # 服务器名称 ssl on; # 开启ssl ssl_certificate /home/LuGH/key/server.crt; # ssl证书 ssl_certificate_key /home/LuGH/key/server.key; # ssl证书密匙 ssl_session_timeout 5m; # 分配客户端可以重复使用存储在缓存中的会话参数的时间。 ssl_protocols SSLv2 SSLv3 TLSv1; # 指令启用指定的协议 ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2+EXP; # 指令描述允许的密码。密码以OpenSSL支持的格式分配 ssl_prefer_server_ciphers on; # 需要协议SSLv3和TLSv1服务器密码优于客户端的密码 location / &#123; proxy_set_header X-Forwarded-Proto https; # 重新定义或添加字段传递给代理服务器的请求头 只允许https访问 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段是不是https proxy_set_header Host $http_host; # 设置Host proxy_redirect off; # 关闭重定向 proxy_pass http://sserver; # 忽略代理 &#125; &#125;&#125;]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
</search>
